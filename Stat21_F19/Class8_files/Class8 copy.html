<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Class 8</title>
    <meta charset="utf-8" />
    <meta name="author" content="Suzanne Thornton" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Class 8
## STAT 021
### Suzanne Thornton
### Swarthmore College
### 2019/9/18 (updated: 2019-09-18)

---




&lt;style type="text/css"&gt;
pre {
  background: #FFBB33;
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;



&lt;img src="Figs/linear_regression_joke1.png" style="display: block; margin: auto;" /&gt;


.footnote[https://xkcd.com/1725/]

---
## A simple statistical model 

`$$Y = f(x) + \epsilon$$`

- `\(f\)` is a smooth function.
  
  - In linear regression, we consider functions with linear coefficients. These coefficients are our model parameters. (I.e. `\(f\)` is just the equation for a line.)

- `\(x\)` is a fixed/known covariate. 

- `\(\epsilon\)` is some random measurement error. Note that, against convention, even though this is a Greek letter, `\(\epsilon\)` represents a **random variable**!


---
## Simple linear regression


Statistical convention represents this line with a intercept, `\(\beta_0\)`, and a slope `\(\beta_1\)` so that we have the following **simple linear regression model**:
`$$Y = \beta_0 + \beta_1 x + \epsilon.$$`


- `\(Y\)` is the response (output) variable. We assume that there is some random error associated with our observations of `\(Y\)`.
- `\(x\)` is a predictor (explanatory, covariate, input) variable. We assume there is **no** random error associated with `\(x\)`, i.e. that all values of `\(x\)` are fixed, so it's not a random variable.  
- `\(\beta_{j}\)` for `\(j=\{0,1\}\)` are the regression model coefficients 

***

Compare this to the the typical algebraic notation for the equation of a line: 
`$$Y = ax + b.$$`

---
## Example with diamond data


```r
diamond_dat &lt;- read_table2("diamond_dat.txt", col_names = FALSE)
colnames(diamond_dat) &lt;- c("size", "price")
head(diamond_dat)
```

```
## # A tibble: 6 x 2
##    size price
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  0.17   355
## 2  0.16   328
## 3  0.17   350
## 4  0.18   325
## 5  0.25   642
## 6  0.16   342
```

.footnote[Source: Singfat Chu. National University of Singapore. Journal of Statistics Education v.4, n.3 (1996).]


---
## Example with diamond data


```r
ggplot(diamond_dat, aes(x=size, y=price)) +
  geom_point() + 
  geom_smooth(method = "lm", se=FALSE) +
  labs(title="Simple Linear Reguression", subtitle="Diamond size as a predictor of diamond price",
       x="Size \n (carats)", y="Price \n (Singapore dollars") 
```

&lt;img src="Figs/diamondEx-1.png" style="display: block; margin: auto;" /&gt;

---
## Simple linear regression 

It's called a linear model because `\(f\)` is linear with respect to the coefficients `\(\beta_{j}\)`, for `\(j=\{0,1\}\)`. 


**Question:** Which of the following are linear models? 

`$$Y = \beta_{0} + \beta_{1}x^2 + \epsilon$$` 
&lt;strike&gt;$$Y = \beta_{0} + \beta_{1}^2x + \epsilon$$&lt;/strike&gt; 




---
## Simple linear regression

`$$Y = \beta_0 + \beta_1 x + \epsilon.$$`

For now, we are only going to consider the case where `\(x\)` and `\(Y\)` both represent **quantitative, continuous** random variables.


We will be generalizing this SLR (simple linear regression) model to cases where 

  - X is a discrete and quantitative variable; 
  
  - X is a discrete and qualitative variable (ANOVA);

  - We have more than just one predictor variable (MLR); 

  - Y is a binary variable (logistic regression) - time permitting.
  
---
## Diamond data example



```r
SLR_diamonds &lt;- lm(price~size, data=diamond_dat)
summary(SLR_diamonds)
```

```
## 
## Call:
## lm(formula = price ~ size, data = diamond_dat)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -85.159 -21.448  -0.869  18.972  79.370 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  -259.63      17.32  -14.99   &lt;2e-16 ***
## size         3721.02      81.79   45.50   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 31.84 on 46 degrees of freedom
## Multiple R-squared:  0.9783,	Adjusted R-squared:  0.9778 
## F-statistic:  2070 on 1 and 46 DF,  p-value: &lt; 2.2e-16
```

---
## Diamond data example


```r
ggplot(diamond_dat, aes(x=size, y=price)) +
  geom_point() + 
  geom_smooth(method = "lm", se=FALSE) +
  labs(title="Simple Linear Reguression", subtitle="Diamond size as a predictor of diamond price",
       x="Size \n (carats)", y="Price \n (Singapore dollars") +
  xlim(0, max(diamond_dat$size)) + ylim(0,max(diamond_dat$price))
```

&lt;img src="Figs/diamondEx3-1.png" style="display: block; margin: auto;" /&gt;
--

For more information on interpreting negative intercept values &lt;a href="https://statisticsbyjim.com/regression/interpret-constant-y-intercept-regression/"&gt;go here&lt;/a&gt;.


---
## Simple linear regression

In SLR, the data we observe are pairs `\((x_{1},y_{1}), \dots, (x_{n},y_{n})\)`, of continuous, quantitative variables. 

The model `\(Y = \beta_0 + \beta_1 x + \epsilon\)` means that we are assuming 
`$$y_{i} = \beta_0 + \beta_1 x_{i} + \epsilon_{i},$$`
for each data point we observe where `\(\epsilon_{i}\)` represents an (unobserved) measurement error associated with our response variable. 


---
## Simple linear regression
`$$Y = \beta_0 + \beta_1 x + \epsilon$$`

**Assumptions**

For estimation: The measurement error has mean `\(E[\epsilon]=0\)` and (unknonw) variance `\(Var[\epsilon]=\sigma^2\)` and all measurement errors are independent of each other. 


For inference: If we wish to conduct statistical inference, we must also assume that the measurement error, `\(\epsilon\)`, is Normally distributed.


--
**Question:** What do theses assumptions imply about `\(Y\)`? 


--
**Another question:** What if there was no random error in our observations of `\(Y\)`? How do we find the line of best fit in this case?


---
## &lt;a href="https://en.wikipedia.org/wiki/Central_limit_theorem#Classical_CLT"&gt;Central limit theorem&lt;/a&gt;

**English version:**

If: `\(X_1, X_2, \dots,X_n\)` are (1)all random variables with the same distribution (e.g. all Poisson, all beta, all t-distributed) and (2)there are no statistical dependencies between any two arbitrary groups of these random variables and (3)the average and variance of these random variables are all the same 


Then the distribution of the average of these `\(n\)` random variables is Gaussian with the same mean and variance as the individual random variables 


**Math version:**

If `\(X_1, X_2, \dots,X_n\)` are all random variables with the same distribution, if they are all independent of one another, and if `\(E[X_{i}]=\mu\)` and `\(Var[X_{i}]=\sigma^2\)` for all `\(i=1,\dots,n\)` then

`$$\bar{X} \sim N(\mu, \sigma).$$`
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
