<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 6 - Part 1</title>
    <meta charset="utf-8" />
    <meta name="author" content="Suzanne Thornton" />
    <link href="week6-part1_files/remark-css/default.css" rel="stylesheet" />
    <link href="week6-part1_files/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Week 6 - Part 1
## Quantiles and Normality
### Suzanne Thornton
### Swarthmore College
### For class in Week 6 (updated: 2021-03-13)

---




&lt;style type="text/css"&gt;
pre {
  background: #FFBB33;
  max-width: 100%;
  overflow-x: scroll;
}

.scroll-output {
  height: 70%;
  overflow-y: scroll;
}

.scroll-small {
  height: 30%;
  overflow-y: scroll;
}
   
.red{color: #ce151e;}
.green{color: #26b421;}
.blue{color: #426EF0;}
&lt;/style&gt;



## How to determine if the population from which you sampled is normal? 


```r
body_temp_dat &lt;- read_table2(url("http://www.swarthmore.edu/NatSci/sthornt1/Stat021/Class3_files/F2019/normtemp_data.txt"))
body_temp_dat %&gt;% head() 
```

```
## # A tibble: 6 x 3
##   Temperature Handedness HeartRate
##         &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1        96.3          1        70
## 2        96.7          1        71
## 3        96.9          1        74
## 4        97            1        80
## 5        97.1          1        73
## 6        97.1          1        75
```
We first try to visualize the data. Typically we plot our response variable as a histogram and/or fit a density curve. 

---
## How to determine if the population from which you sampled is normal? 

&lt;img src="Figs/bodyTempPlot-1.png" style="display: block; margin: auto;" /&gt;
 




---
## Standardizing Data 

If we are given a set of quantitative data, `\(x_{obs} = \{ x_1, x_2, \dots, x_n \}\)`, we can find the sample mean, `\(\bar{x}\)`, and variance, `\(s^2\)`. 

We could also linearly transform this data using the formula
`$$z_i = \frac{x_i-\bar{x}}{s}$$`
so that we have a new set of standardized data `\(z_{obs} = \{z_1, z_2, \dots, z_n \}.\)` We call this data *standardized* because now 
`$$\bar{z} = \frac{1}{n}\sum_{i=1}^{n} z_{i}= 0 \text{ and } s^2_{z}=\frac{1}{n-1}\sum_{i=1}^{n}(z_{i}-\bar{z})^2 =1.$$`

This is a useful technique we will revisit throughout the semester in various contexts. 



---
## QQ Plots
### Normal probability plots

A visually, easier to detect comparison is to look at the &lt;a href="https://en.wikipedia.org/wiki/Quantile"&gt;quantiles&lt;/a&gt; of the observed data and compare them to some hypothetical quantiles of a Gaussian&lt;sup&gt;[1]&lt;/sup&gt; distribution. To do this, we plot the *standardized and ordered* data (from smallest to largest), `$$(z^{(1)}, z^{(2)}, \dots, z^{(n)})$$`
against `\(E[Z^{(i)}],\)` the expected value of the order statistics from a *standard* (mean 0 and s.d. 1) normal distribution. 



Such **QQ plots (Quantile-quantile plots)** generalize to other distributions as well (e.g. T, Gamma, Beta, etc). These plots help us answer the question: "Is the distribution of the data similar to a normal (or T, chi-square, etc) distribution?" 


***
.footnote[[1] Gaussian is just another name for the Normal distribution. (Sometimes it's used because we just the word "normal" so often in English that it can be confusing when talking about Statistics.)]


---
## What are &lt;a href="https://en.wikipedia.org/wiki/Quantile"&gt;quantiles&lt;/a&gt;?

.scroll-output[R can find the quantiles for any common distribution functions very easily:


```r
normal_quantiles &lt;- qnorm(p=seq(0,1,0.1), mean=0, sd=1, lower.tail=TRUE)
normal_quantiles
```

```
##  [1]       -Inf -1.2815516 -0.8416212 -0.5244005 -0.2533471  0.0000000
##  [7]  0.2533471  0.5244005  0.8416212  1.2815516        Inf
```


```r
t_quantiles &lt;- qt(p=seq(0,1,0.1), df=8, lower.tail=TRUE)
t_quantiles
```

```
##  [1]       -Inf -1.3968153 -0.8888895 -0.5459338 -0.2619211  0.0000000
##  [7]  0.2619211  0.5459338  0.8888895  1.3968153        Inf
```
]

.footnote[Here is a useful guide to all the base R density, distribution, quantile, and random generating functions: http://www.stat.umn.edu/geyer/old/5101/rlook.html]

---
## Example of finding a sample quantile

Find the number in the following set of data where 20 percent of values fall below it, and 80 percent fall above:

1 3 5 6 9 11 12 13 19 21 22 32 35 36 45 44 55 68 79 80 81 88 90 91 92 100 112 113 114 120 121 132 145 146 149 150 155 180 189 190
***

**Step 1:** Order the data from smallest to largest. 

**Step 2:** Count how many observations you have in your data set. this particular data set has 40 items.

**Step 3:** We are looking for the number where 20 percent of the values fall below it, so find the `\((40\times0.2)=8^{th}\)` smallest number in the ordered data set. 

The `\(20^{th}\)` quantile is the number 13. 



---
## Example of finding a sample quantile

Find the number in the following set of data where 20 percent of values fall below it, and 80 percent fall above:

1 3 5 6 9 11 12 13 19 21 22 32 35 36 45 44 55 68 79 80 81 88 90 91 92 100 112 113 114 120 121 132 145 146 149 150 155 180 189 190
***

Or, just use R! Because R can also very easily find sample quantiles. 


```r
my_samp &lt;- c(1, 3, 5, 6, 9, 11, 12, 13, 19, 21, 22, 32, 35, 36, 45, 44, 55, 68, 79, 80, 81, 88, 90, 91, 92, 100, 112, 113, 114, 120, 121, 132, 145, 146, 149, 150, 155, 180, 189, 190)
quantile(my_samp, probs = 0.2, type=3)  ##there are several ways to calculate a quantile but this is the one that we are using
```

```
## 20% 
##  13
```


---
## Interpreting normal probability plots 
### (I.e. QQ plots for normality)

Interpretation: A linear relationship close to the diagonal line `\(x=y\)` indicates a close matching of your observed data with a Normal distribution. 


For example, let's create a fake data set from a Normal distribution and view a QQ plot for this data:


```r
set.seed(100)
fake_dat &lt;- tibble(observedData = rnorm(n=50,mean=3,sd=1.2))  ##fake data that is reprodcable becase I set the random seed
fake_dat &lt;- fake_dat %&gt;% 
            mutate(standardData = (observedData-mean(observedData))/sd(observedData))
```


---
## Interpreting normal probability plots 
### (I.e. QQ plots for normality)

.scroll-output[

```r
ggplot(data = fake_dat, aes(sample=standardData)) + ##not we specify the sample rather than an X or Y axis 
  stat_qq() + 
  stat_qq_line()  +
  labs(title = "Normal probability plot", 
       subtitle = "Fake data from a normal distribution") 
```

![](Figs/qqPlotFakeClass6-1.png)&lt;!-- --&gt;
]




---
## Interpreting normal probability plots 
### (I.e. QQ plots for normality)

.scroll-output[
Now lets investigate the body temperature data again. 

&lt;img src="Figs/qqPlotTempClass6_@-1.png" style="display: block; margin: auto;" /&gt;


This matches pretty well with the theoretical quantiles of a normal distribution. 

**Q:** What behavior do you need to look out for?  

**A:** Deviations in the tails! If the lower quantiles of the sample are smaller than we expect and/or the upper quantiles of the sample are higher than we expect, that means our data has *heavier tails* than a normal distribution. 
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"navigation": {
"scroll": false
}
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
